//
//void EncrypFile(const std::string& inputFileName, const std::string& outputFileName, const unsigned char key[AES_BLOCK_SIZE], const unsigned char iv[AES_BLOCK_SIZE]) {
//    std::ifstream inFile(inputFileName, std::ios::binary);
//    if (!inFile.is_open()) {
//        throw std::runtime_error("Unable to open input file for reading");
//    }
//
//    std::vector<unsigned char> content((std::istreambuf_iterator<char>(inFile)), std::istreambuf_iterator<char>());
//    inFile.close();
//
//    AES_KEY encryptKey;
//    AES_set_encrypt_key(key, 128, &encryptKey);
//
//    std::vector<unsigned char> cipherContent(content.size());
//    int num = 0;
//    unsigned char currentIV[AES_BLOCK_SIZE];
//    memcpy(currentIV, iv, AES_BLOCK_SIZE);
//
//    AES_cfb128_encrypt(content.data(), cipherContent.data(), content.size(), &encryptKey, currentIV, &num, AES_ENCRYPT);
//
//    std::ofstream outFile(outputFileName, std::ios::binary);
//    if (!outFile.is_open()) {
//        throw std::runtime_error("Unable to open output file for writing");
//    }
//
//    outFile.write(reinterpret_cast<char*>(cipherContent.data()), cipherContent.size());
//    outFile.close();
//}
//
//// Dosya deşifreleme fonksiyonu
//void DecrypFile(const std::string& inputFileName, const std::string& outputFileName, const unsigned char key[AES_BLOCK_SIZE], const unsigned char iv[AES_BLOCK_SIZE]) {
//    std::ifstream inFile(inputFileName, std::ios::binary);
//    if (!inFile.is_open()) {
//        throw std::runtime_error("Unable to open input file for reading");
//    }
//
//    std::vector<unsigned char> content((std::istreambuf_iterator<char>(inFile)), std::istreambuf_iterator<char>());
//    inFile.close();
//
//    AES_KEY decryptKey;
//    AES_set_decrypt_key(key, 128, &decryptKey);
//
//    std::vector<unsigned char> plainContent(content.size());
//    int num = 0;
//    unsigned char currentIV[AES_BLOCK_SIZE];
//    memcpy(currentIV, iv, AES_BLOCK_SIZE);
//
//    AES_cfb128_encrypt(content.data(), plainContent.data(), content.size(), &decryptKey, currentIV, &num, AES_DECRYPT);
//
//    std::ofstream outFile(outputFileName, std::ios::binary);
//    if (!outFile.is_open()) {
//        throw std::runtime_error("Unable to open output file for writing");
//    }
//
//    outFile.write(reinterpret_cast<char*>(plainContent.data()), plainContent.size());
//    outFile.close();
//}

int main() {
    /*try {
        Aes aes;
        unsigned char key[AES_BLOCK_SIZE], iv[AES_BLOCK_SIZE];

        aes.initializeKey(key, iv);

        std::string inputFileName = "plaintext.txt";
        std::string encryptedFileName = "encrypted.txt";
        std::string decryptedFileName = "decrypted.txt";

        // Test verisi olarak bir dosya oluşturalım
        std::ofstream plainFile(inputFileName, std::ios::binary);
        plainFile << "This is a test file for AES encryption.";
        plainFile.close();

        // Dosyayı şifreleyelim
        aes.EncrypFile(inputFileName, encryptedFileName, key, iv);
        std::cout << "File encrypted successfully.\n";

        //std::this_thread::sleep_for(std::chrono::seconds(120));
        // Dosyayı deşifreleyelim
        aes.DecrypFile(encryptedFileName, decryptedFileName, key, iv);
        std::cout << "File decrypted successfully.\n";

        // Deşifrelenmiş dosyanın içeriğini okuyup doğrulayalım
        std::ifstream decryptedFile(decryptedFileName, std::ios::binary);
        std::string decryptedContent((std::istreambuf_iterator<char>(decryptedFile)), std::istreambuf_iterator<char>());
        decryptedFile.close();

        std::cout << "Decrypted file content: " << decryptedContent << "\n";

    }
    catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        return 1;
    }
    */
    return 0;

}